package io.openbas.rest.inject.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.node.ObjectNode;
import io.openbas.database.model.*;
import io.openbas.database.repository.AgentRepository;
import io.openbas.database.repository.InjectStatusRepository;
import io.openbas.rest.exception.ElementNotFoundException;
import io.openbas.rest.finding.FindingService;
import io.openbas.rest.inject.form.InjectExecutionInput;
import java.time.Instant;
import java.util.Optional;
import java.util.Set;
import java.util.logging.Level;
import lombok.RequiredArgsConstructor;
import lombok.extern.java.Log;
import org.springframework.stereotype.Service;

@RequiredArgsConstructor
@Service
@Log
public class InjectExecutionService {

  private final AgentRepository agentRepository;
  private final InjectStatusService injectStatusService;
  private final FindingService findingService;
  private final StructuredOutputUtils structuredOutputUtils;
  private final InjectStatusRepository injectStatusRepository;

  public void handleInjectExecutionCallback(
      String executionId, String agentId, InjectExecutionInput input) {
    InjectStatus execution = null;

    try {
      execution = loadExecutionOrThrow(executionId);
      Agent agent = loadAgentIfPresent(agentId);

      Set<OutputParser> outputParsers =
          structuredOutputUtils.extractOutputParsers(execution.getInject());
      Optional<ObjectNode> structuredOutput =
          structuredOutputUtils.computeStructuredOutput(outputParsers, input);

      processInjectExecution(execution, agent, input, outputParsers, structuredOutput);
    } catch (ElementNotFoundException | JsonProcessingException e) {
      handleInjectExecutionError(execution, e);
    }
  }

  /** Processes the execution of an inject by updating its status and extracting findings. */
  private void processInjectExecution(
      InjectStatus execution,
      Agent agent,
      InjectExecutionInput input,
      Set<OutputParser> outputParsers,
      Optional<ObjectNode> structuredOutput) {

    ObjectNode structured = structuredOutput.orElse(null);
    injectStatusService.updateExecutionStatus(agent, execution, input, structured);

    if (structured != null) {
      if (agent != null) {
        // Extract findings from structured outputs generated by the output parsers specified in the
        // payload, typically derived from the raw output of the implant execution.
        findingService.extractFindingsFromOutputParsers(
            execution, agent, outputParsers, structured);
      } else {
        // Structured output directly provided (e.g., from injectors)
        findingService.extractFindingsFromInjectorContract(execution, structured);
      }
    }
  }

  private Agent loadAgentIfPresent(String agentId) {
    return (agentId == null)
        ? null
        : agentRepository
            .findById(agentId)
            .orElseThrow(() -> new ElementNotFoundException("Agent not found: " + agentId));
  }

  private InjectStatus loadExecutionOrThrow(String executionId) {
    return injectStatusRepository
        .findById(executionId)
        .orElseThrow(() -> new ElementNotFoundException("Inject not found: " + executionId));
  }

  private void handleInjectExecutionError(InjectStatus execution, Exception e) {
    log.log(Level.SEVERE, e.getMessage());
    if (execution != null) {
      ExecutionTrace trace =
          new ExecutionTrace(
              execution,
              ExecutionTraceStatus.ERROR,
              null,
              e.getMessage(),
              ExecutionTraceAction.COMPLETE,
              null,
              Instant.now());
      execution.addTrace(trace);
      injectStatusRepository.save(execution);
    }
  }
}
